#include "imports/stdlib.fc";
#include "imports/constants.fc";

#include "storage.fc";
#include "verifier.fc";

;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    (int workchain,int addr) = parse_std_addr(sender_address);

   ;;TODO: Get from the Dict and Set to the dict
   ;;Create message encoders and decoders, kind of like a struct but stored in the dict per key

    ;; cell dict = storage::load_data(); ;; here we get the dict from storage
 

    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case

    
    if(op == op::deposit){
        ;;Deposit tBTC jettons with a commitment and save them into a dictionary

        ;;Load the commitment from the body

        ;;Load the deposit amount from the body

        ;; Make sure the jettons a re transferred here

        ;; Update the dict

        ;;Check to make sure the commitment doesn't exist  yet
        return ();
    }

    if(op == op::withdraw){
        ;;Call the ZKP verifier here
        slice pi_a = in_msg_body~verifier::load_p1();
        slice pi_b = in_msg_body~verifier::load_p2();
        slice pi_c = in_msg_body~verifier::load_p1();

        int pubInput0 = in_msg_body~verifier::load_newint(); ;; This is the nullifierHash
        int pubInput1 = in_msg_body~verifier::load_newint(); ;; This is the commitment hash

;;        int pubInput2 = in_msg_body~verifier::load_newint();
        
;;        int pubInput3 = in_msg_body~verifier::load_newint();

        int verificationResult =  verifier::groth16Verify(pi_a,pi_b,pi_c,pubInput0,pubInput1,workchain, addr ); ;; addr, workchain); ;;Using the sender's address for the pubInput2
        
        ;;  ~dump(verificationResult);

         throw_if(exec::invalid_proof, verificationResult == 0);

        ;; (slice deposit,int found) = dict.idict_get?(dict,256,pubInput1); ;;Pubinput 1 should be the commitment

        ;; throw_unless(exec::deposit_not_found, found == -1); ;; If the Deposit is not found, throw

        ;; TODO: Check if the deposit was withdrawn already!

        ;;TODO: If not, then withdraw it to the sender's address

        ;;TODO: Then set it withdrawn using the nullifierHash
        
        ;;Mutate the dict, then save it back

        ;;   storage::save_data(dict);
        return ();
    };

    throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
}

;; Checks if there is a deposit at commitment and returns the slice stored at that index in the dict
;; The slice contains the deposit amount and if it's been nullified or not
(slice) get_deposit(int commitment) method_id {
    cell dict = storage::load_data();
    
     (slice payload, int success) = dict.udict_get?(256, commitment);

    throw_unless(exec::deposit_not_found,success);

    return (payload);
}