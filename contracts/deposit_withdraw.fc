#include "imports/stdlib.fc";
#include "imports/constants.fc";

#include "storage.fc";
#include "verifier.fc";
#include "packing.fc";

;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    (int workchain,int addr) = parse_std_addr(sender_address);

   ;;Create message encoders and decoders, kind of like a struct but stored in the dict per key

    cell dict = storage::load_data(); ;; here we get the dict from storage
 
    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case

    ;; TODO: It will be transfer notify
    
    if(op == op::deposit){
        cell deposit_data = in_msg_body~load_ref();
        slice s = deposit_data.begin_parse();
        int commitment = s~load_uint(256);
        int depositAmount = s~load_coins();

        cell packedDepositData = packing::pack_depositData(
            0,
            depositAmount);

        
         (cell newDict, int success)  =  udict_add?(dict, 256, commitment, packedDepositData.begin_parse());

        ;;Check to make sure the commitment doesn't exit, yet
        throw_if(exec::deposit_already_exists, success == 0);

        ;;TODO: Deposit tBTC jettons 

        ;; Update the dict
         storage::save_data(newDict);
        return ();
    }

    if(op == op::withdraw){
        ;;Call the ZKP verifier here
        slice pi_a = in_msg_body~verifier::load_p1();
        slice pi_b = in_msg_body~verifier::load_p2();
        slice pi_c = in_msg_body~verifier::load_p1();

        int pubInput0 = in_msg_body~verifier::load_newint(); ;; This is the nullifierHash
        int pubInput1 = in_msg_body~verifier::load_newint(); ;; This is the commitment hash
        ;;int pubInput2 = in_msg_body~verifier::load_newint(); ;;The workchain value is taken from the address       
        ;;int pubInput3 = in_msg_body~verifier::load_newint(); ;; The address is taken from the sender

        int verificationResult =  verifier::groth16Verify(pi_a,pi_b,pi_c,pubInput0,pubInput1,workchain, addr ); ;;Using the sender's address for the pubInput2
        
        throw_if(exec::invalid_proof, verificationResult == 0);

        (slice payload,int found) = dict.udict_get?(256,pubInput1); ;;Get the withdraw data by commitment
        
        throw_unless(exec::deposit_not_found, found); ;; If the Deposit is not found, throw

        (int nullifierHash, int depositAmount) = packing::unpack_depositData(payload);
        
        ;; Check if the deposit was withdrawn already, if the nullifierHash is zero then it was not withrawn
        throw_if(exec::deposit_nullified, nullifierHash != 0);

        ;;TODO: Withdraw Jetton to the sender's address!

        ;;Nullify the amount
        cell packedDepositData = packing::pack_depositData(
            pubInput0, ;;NullifierHash
            depositAmount); ;;This deposit amount is nullified now


        ;;Upate the dict
        cell newDict = udict_set(dict,256,pubInput1,packedDepositData.begin_parse());

        storage::save_data(newDict);

        return ();
    };

    throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
}

;; Checks if there is a deposit at commitment and returns the slice stored at that index in the dict
;; The slice contains the deposit amount and if it's been nullified or not
(int,int) get_deposit(int commitment) method_id {
    cell dict = storage::load_data();
    
     (slice payload, int success) = dict.udict_get?(256, commitment);

    throw_unless(exec::deposit_not_found,success);

    return packing::unpack_depositData(payload);
}